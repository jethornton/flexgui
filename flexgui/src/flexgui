#!/usr/bin/env python3

import os, sys, subprocess

# disable cache usage must be before any local imports
sys.dont_write_bytecode = True

from functools import partial

from PyQt6.QtWidgets import QApplication, QMainWindow, QMessageBox
from PyQt6.uic import loadUi
from PyQt6.QtCore import QObject, Qt, QTimer, QEvent
from PyQt6.QtGui import QKeyEvent

import linuxcnc as emc
import hal

from libflexgui import read_ini
from libflexgui import startup
from libflexgui import status
from libflexgui import dialogs
from libflexgui import commands
from libflexgui import utilities
from libflexgui import shutdown

class KeyboardJog(QObject):
	def __init__(self, window):
		super().__init__()
	def eventFilter(self, source, event):
		# jog events check for state estop and release if keyboard_jogging is true
		# enable_ctrl_kb_jog or enable_cb_kb_jog
		if event.type() == QEvent.Type.KeyPress:
			if window.status.task_state == emc.STATE_ON and window.status.task_mode == emc.MODE_MANUAL:
				jog = False
				if window.kb_jog_ctrl_enabled and event.modifiers() & Qt.KeyboardModifier.ControlModifier:
					jog = True
				elif window.kb_jog_cb_enabled:
					jog = True

				if jog:
					if event.key() == Qt.Key.Key_Left:
						if event.isAutoRepeat():
							return True  # Consume the event
						commands.keyboard_jog(window, True, 0, 'neg')
						return True  # Consume the event
					elif event.key() == Qt.Key.Key_Right:
						if event.isAutoRepeat():
							return True  # Consume the event
						commands.keyboard_jog(window, True, 0, 'pos')
						return True  # Consume the event
					elif event.key() == Qt.Key.Key_Up:
						if event.isAutoRepeat():
							return True  # Consume the event
						commands.keyboard_jog(window, True, 1, 'pos')
						return True  # Consume the event
					elif event.key() == Qt.Key.Key_Down:
						if event.isAutoRepeat():
							return True  # Consume the event
						commands.keyboard_jog(window, True, 1, 'neg')
						return True  # Consume the event
					elif event.key() == Qt.Key.Key_PageUp:
						if event.isAutoRepeat():
							return True  # Consume the event
						commands.keyboard_jog(window, True, 2, 'pos')
						return True  # Consume the event
					elif event.key() == Qt.Key.Key_PageDown:
						if event.isAutoRepeat():
							return True  # Consume the event
						commands.keyboard_jog(window, True, 2, 'neg')
						return True  # Consume the event
				else:
					return super().eventFilter(source, event) # pass the event on if not used
			else:
				return super().eventFilter(source, event) # pass the event on if not used

		elif event.type() == QEvent.Type.KeyRelease:
			if window.kb_jog_cb_enabled or window.kb_jog_ctrl_enabled:
				# RCS_EXEC while jogging and RCS_DONE when finished
				if window.status.task_state == emc.STATE_ON:
					if not event.isAutoRepeat():# and window.keyboard_jogging:
						match event.key():
							case Qt.Key.Key_Left | Qt.Key.Key_Right:
								commands.keyboard_jog(window, False, 0)
							case Qt.Key.Key_Up | Qt.Key.Key_Down:
								commands.keyboard_jog(window, False, 1)
							case Qt.Key.Key_PageUp | Qt.Key.Key_PageDown:
								commands.keyboard_jog(window, False, 2)
							case Qt.Key.Key_Control:
								commands.keyboard_jog(window, False)
						return True  # Consume the event

		if event.type() == QEvent.Type.MouseButtonRelease:
			if source.objectName() in window.number_le:
				dialogs.numbers(window, source)
			elif source.objectName() in window.nccode_le:
				dialogs.gcode(window, source)
			elif source.objectName() in window.keyboard_le:
				dialogs.keyboard(window, source)
			elif source.objectName() in window.touch_sb:
				dialogs.spinbox_numbers(window, source.parent())

		return super().eventFilter(source, event) # pass the event on if not used

class flexgui(QMainWindow):
	def __init__(self):
		super().__init__()

		self.flex_version = '1.3.2'

		self.path = os.path.dirname(os.path.realpath(sys.argv[0]))
		# set the library path
		if self.path == '/usr/bin':
			self.lib_path = '/usr/lib/libflexgui'
			self.gui_path = '/usr/lib/libflexgui'
		else:
			msg = ('Flex GUI seems to be installed\n'
			'in a none standard location.')
			dialogs.error_msg_ok(self, msg, 'Error')
			sys.exit()

		# connect to linuxcnc
		self.status = emc.stat()
		self.status.poll()
		# initalize exec_state and task_state which is checked in status.py
		self.exec_state = self.status.exec_state
		self.task_state = self.status.task_state
		self.task_mode = self.status.task_mode
		self.interp_state = self.status.interp_state
		self.motion_mode = self.status.motion_mode
		self.motion_type = self.status.motion_type
		self.state = self.status.state
		self.command = emc.command()
		self.error = emc.error_channel()
		self.flood_state = self.status.flood
		self.mist_state = self.status.mist
		self.tool_in_spindle = self.status.tool_in_spindle
		self.help_dialog = None
		self.keyboard_jogging = False

		self.home_dir = os.path.expanduser('~')

		# setup hal components
		self.halcomp = hal.component('flexhal')
		self.toolcomp = hal.component('tool-change')

		for i in range(len(sys.argv)): # check if running from ini DISPLAY entry
			if sys.argv[i].endswith('.ini'):
				# self.ini_path path to ini file
				self.ini_path = sys.argv[i]
				self.inifile = emc.ini(sys.argv[i])
				# self.config_path path to configuration
				self.config_path = os.path.split(sys.argv[i])[0]
				break
		else: # no match was found
			msg = ('Flex GUI must be called from\n'
			'the LinuxCNC ini file.')
			dialogs.error_msg_ok(self, msg, 'Error')
			sys.exit()

		# find and load the gui
		gui_file = self.inifile.find('DISPLAY', 'GUI') or False
		if gui_file: # gui is in the ini file
			gui_path = os.path.join(os.path.dirname(self.status.ini_filename), gui_file)
			if not os.path.isfile(gui_path): # gui not found
				gui_path = os.path.join(self.gui_path, 'flex_default.ui')
				gui_file = 'flex_default.ui'
		else: # no gui specified
			gui_path = os.path.join(self.gui_path, 'flex_default.ui')
			gui_file = 'flex_default.ui'

		loadUi(gui_path, self)
		machine = self.inifile.find('EMC', 'MACHINE') or False
		if machine:
			self.setWindowTitle(f'{machine} Flex GUI V{self.flex_version}')
		else:
			self.setWindowTitle(f'Flex GUI - Version: {self.flex_version} - Using {gui_file}')

		# get a list of axis letters in the configuration
		axis_list = ['X', 'Y', 'Z', 'A', 'B', 'C', 'U', 'V', 'W']
		axis_map = f'{self.status.axis_mask:09b}'
		self.axis_letters = []
		for i, a in enumerate(reversed(axis_map)):
			if a == '1':
				self.axis_letters.append(axis_list[i])

		# get the number of axes and joints
		self.axis_count = self.status.axis_mask.bit_count()
		#self.joints = self.status.joints

		# get ini values if any before trying to use them
		read_ini.read(self)

		# check for a resources.py file with images for the stylesheet
		if self.resources_file: # import the resources file
			try:
				sys.path.append(self.config_path)
				import resources
			except:
				msg = (f'The resources file {resources_file} was\n'
					'not found, check for file name resources.py.')
				dialogs.warn_msg_ok(parent, msg, 'Import Failed')

		stylesheet = False
		if self.theme:
			valid_themes = ['keyboard', 'touch', 'blue', 'blue-touch', 'dark', 'dark-touch']
			if self.theme in valid_themes:
				stylesheet = os.path.join(self.lib_path, f'{self.theme}.qss')
				from libflexgui import resources
		elif self.qss_file: # use a local qss file
			stylesheet = os.path.join(self.config_path, self.qss_file)

		if stylesheet:
			if os.path.isfile(stylesheet):
				with open(stylesheet, 'r') as f:
					self.setStyleSheet(f.read())
			else:
				msg = (f'The Stylesheet {stylesheet}\n'
					'was not found.')
				dialogs.warn_msg_ok(parent, msg, 'INI Error')

		self.status.poll()
		self.directory = dir(self) # get variable and object names before hal
		startup.set_screen(self)
		startup.setup_vars(self)
		startup.setup_hal_led_buttons(self)
		startup.setup_hal_led_labels(self)
		startup.setup_hal_leds(self)
		startup.find_children(self)
		startup.setup_enables(self)
		startup.setup_menus(self) # setup menus adds to child names
		startup.setup_actions(self) # setup actions adds to child names
		startup.update_check(self)
		startup.setup_plot(self)
		startup.setup_buttons(self)
		startup.setup_status_labels(self)
		startup.setup_list_widgets(self)
		startup.setup_plain_text_edits(self)
		startup.setup_stacked_widgets(self)
		startup.setup_spin_boxes(self)
		startup.setup_line_edits(self)
		startup.setup_spindle(self)
		startup.setup_jog(self)
		startup.setup_jog_selected(self)
		startup.setup_probing(self)
		startup.setup_mdi(self)
		startup.setup_mdi_buttons(self)
		startup.setup_set_var(self)
		startup.setup_watch_var(self)
		startup.setup_tools(self)
		startup.setup_hal(self)
		startup.setup_touchoff(self)
		startup.setup_sliders(self)
		startup.setup_overrides(self)
		startup.setup_defaults(self)
		startup.setup_tool_change(self)
		startup.setup_toolbar(self)
		startup.setup_fsc(self)
		startup.setup_dsf(self)
		startup.setup_tpc(self)
		startup.setup_help(self)
		startup.setup_tabs(self)
		# loading the post gui files can only happen once
		startup.load_postgui(self)

		startup.set_status(self)

		self.user_timer = QTimer()
		startup.setup_import(self) # do this after user timer is created

		# setup and start the status update timer every 0.01 second
		self.timer = QTimer()
		self.timer.timeout.connect(partial(status.update, self))
		self.timer.start(10) # milliseconds

		# var update timer
		self.var_timer = QTimer(self)
		self.var_timer.setSingleShot(True)
		self.var_timer.timeout.connect(partial(utilities.sync_var_file, self))

		# setup the var file watch timer
		self.var_watch_timer = QTimer(self)
		self.var_watch_timer.timeout.connect(partial(utilities.var_file_watch, self))
		self.var_mod_time = 0.0 # used to watch the file modification time
		self.var_watch_timer.start(100) # milliseconds

		# setup the i/o watch timer
		self.io_watch_timer = QTimer(self)
		self.io_watch_timer.timeout.connect(partial(utilities.io_watch, self))
		self.io_watch_timer.start(1000) # milliseconds

		# test timer
		self.one_second_timer = QTimer(self)
		self.one_second_timer.start(1000) # milliseconds

		# flashing button timer
		self.button_flash_timer = QTimer(self)
		self.button_flash_timer.timeout.connect(partial(utilities.flash_buttons, self))
		self.button_flash_timer.start(1000) # milliseconds

		# install the KeyboardJog event filter
		self.keyboard_jog = KeyboardJog(self)
		app.installEventFilter(self.keyboard_jog)

		# set the inital screen size
		match self.screen_size:
			case 'minimized':
				self.showMinimized()
			case 'normal':
				self.showNormal()
			case 'maximized':
				self.showMaximized()
			case 'full':
				self.showFullScreen()
			case _:
				self.show()

	# this can import a module from a file for resources.py in a config dir
	def module_from_file(self, module_name, file_path):
		spec = importlib.util.spec_from_file_location(module_name, file_path)
		module = importlib.util.module_from_spec(spec)
		spec.loader.exec_module(module)
		return module

	def resizeEvent(self, event):
		if 'window_size_lb' in self.child_names:
			width = self.geometry().width()
			height =  self.geometry().height()
			self.window_size_lb.setText(f'{width}x{height}')
		QMainWindow.resizeEvent(self, event)

	def closeEvent(self, event):
		shutdown.save_settings(self)
		if self.help_dialog is not None:
			self.help_dialog.close()

app = QApplication(sys.argv)
window = flexgui()
sys.exit(app.exec())

